---
layout: post
comments: true
title: Web Abstractions
date: 2018-03-26 08:10:00
description: Web abstractions in Ruby, Java, and Clojure
---


This post will be mostly focused on web abstractions in Ruby, Java, and Clojure. All of these languages have
web application libraries that abstract the details of HTTP into a simple, unified API. The goal 
of these libraries is to provide a minimal API for connecting web servers (i.e. WEBrick) and web frameworks (i.e. Rails, Sinatra). There are other languages that also have similar web abstractions but I'm mostly going to be focusing on these languages specifically. 


### Rack 
<br> 


I've worked with both Rails and Sinatra and remember hearing about Rack occasionally when I first started
learning the frameworks. It turns out, Rails (and Sinatra) are built on top of Rack or have a Rack interface
for allowing web servers to connect to them. 

Rack is a Ruby package that provides an easy-to-use interface to the Ruby [Net::HTTP](http://ruby-doc.org/stdlib-2.2.0/libdoc/net/http/rdoc/Net/HTTP.html) library. Put simply, it allows you to easily deal with HTTP requests. 


We know that HTTP protocol describes the activity of a client sending an HTTP request to a server and the 
server returning a response. Both the request and the response have similar structures consisting of a status line, headers, and an optional body. 

Rack is similar. It's a Ruby object that has a call method which has a single argument, the environment which corresponds to a HTTP request, and returns an array of 3 elements: status, headers, and a body. 

Rack includes handlers that connect Rack to web servers like WEBrick and it includes adapters that connect Rack to various web frameworks like Rails and Sinatra. 


Rack compliant code must have the following three characteristics: 

* It must respond to `call`
* The `call` method must accept a single argument which is typically called `env` and it bundles up all of the data about the request
* The `call` method must return an array of three elements (status, headers, and body)


The environment argument that I've been referring to is a hash that consists of the request method, request path, server name, server port, and query string among some other optional information. 


```ruby
require 'rack'

class RequestHandler 
  def call(env)
    [200, { "Content-Type" => "text/plain"}, ["Hello World"]]
  end
end

Rack::Handler::WEBrick.run(RequestHandler.new, :port => 8080)
# instantiate the RequestHandler and tell Rack we want to use port 8080

```



In the above example when we instantiate `RequestHandler`, call `run`, and visit `localhost:8080` we would see Hello World. Pretty cool! 

### Ring 
<br>

Clojure's ring is very similar to Rack, in fact, it was inspired by Ruby's Rack and 
Pythons WSGI. A web application developed for Ring consists of: Handlers, Requests, Responses, and Middleware. 

**Handlers**
<br> 

Handlers are functions that define your web app. They take one argument (similar to `call` taking `env` in Rack) which represents the HTTP request and returns a map representing an HTTP response. Here is a basic example. 



```clojure
(defn test [request]
  {:status 200
    :headers {"Content-Type" "text-plain"}
    :body "hello world"})
```


**Requests** 
<br> 

As we mentioned, HTTP requests in Ring are represented by maps. There are some keys
that will always exist. Here are some of the standard keys: 

* `:server-port` - The port on which the request is being handled
* `:server-name` - The resolved server name, or the server IP address
* `:remote-addr` - The IP address of the client or last proxy that sent the request
* `:uri` - The request URI (the full path after the domain name)
* `:scheme` - The transport protocol, either http or https
* `:request-method` - HTTP request method (i.e. GET, POST, etc.)
* `:headers` - A map consisting of name name string and their value 
* `:body` - An InputStream for the request body if it's present


**Responses** 
<br> 

The response map is created by the handler and contain only three keys: 

* `:status` - The HTTP Status Code (i.e. 200, 400, 404, etc.)
* `:headers` - A map of HTTP header names and header values
* `:body` - A representation of the body (i.e. String, File, ISeq, or InputStream)


**Middleware** 
<br> 

Middleware are higher-level functions that add functionality to handlers. The first argument of a middleware function should be a handler and the return value should be a new handler function that will call the initial handler. 



```clojure 
(defn wrap-content-type [handler content-type]
  (fn [request]
    (let [response (handler request)]
      (assoc-in response [:headers "Content-Type"] content-type))))

```



This function adds a content-type headers to every response generated by the handler. Below, we can create a new handler called `app` which consists of a handler `file-handler` with the `wrap-content-type` middleware. 


```clojure 
(def app
  (-> file-handler 
    (wrap-content-type)
    (wrap-params)))

```


### Servlet 
<br>

This is a basic diagram of servlets in relation to a web application. 

![servlet](https://www.tutorialspoint.com/servlets/images/servlet-arch.jpg)


Java Servlets are similar to Rack and Ring. A Servlet is a class that handles requests, processes them, and reply back with a response. Servlets are under the control of another Java application called a Servlet Container. When an application receives a request, the Server hands the request to the Servlet Container which then passes it to the target Servlet. 

There are five methods in the Servlet interface: 

* `init()` - Initializes the servlet. It is the life cycle method of the servlet and is invoked by the container only once. 
* `service(ServletRequest request, ServletResponse response)` - This method is called to process the HTTP request. It determines the kind of request being made and dispatches it to an appropriate method to handle the request. This method  It is invoked at each request by the container. 
* `destroy()` - It is invoked only once and indicates the servlet is being destroyed 
* `getServletInto()` - Returns information about servlet such as writer, copyright, version, etc. 



### Conclusion
<br> 

To my surprise, these web abstraction libraries aren't as large and complex as I initially assumed. Each of these web abstraction libraries have very small interfaces and are rather simple from a high level view. 
